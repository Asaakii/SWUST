; 从键盘上输入00-FF之间的任意一个数字，计算其平方值，并将结果用10和16进制在屏幕上显示出来

DATA SEGMENT
	ORIGIN DB 0, 0
	DIVISORS DW 10000, 1000, 100, 10, 1
	RESULT DB 5 DUP(0), '$'
DATA ENDS

STACK SEGMENT PARA STACK 'STACK'
	BUF_1 DW 20H DUP (0)
	LEN EQU $-BUF_1
STACK ENDS

CODE SEGMENT
	ASSUME CS:CODE,DS:DATA,SS:STACK
START:
	MOV AX, DATA
	MOV DS, AX
	MOV AX, STACK
	MOV SS, AX
	MOV SP, LEN

	MOV SI, OFFSET ORIGIN
	CALL INPUT_2_HEX
	MOV [SI], DL   ; SAVE INPUT TO DS:[0]

	CALL CALCULATE_SQUARE

	PUSH AX
	CALL PRINT_ENTER
	MOV SI, OFFSET DIVISORS
	MOV DI, OFFSET RESULT
	MOV CX, 5
A:
	MOV DX, 0
	DIV WORD PTR [SI]
	ADD AL, 48
	MOV BYTE PTR [DI], AL
	INC DI
	ADD SI, 2
	MOV AX, DX
	LOOP A

	MOV CX, 4
	MOV DI, OFFSET RESULT
B:
	CMP BYTE PTR [DI], '0'
	JNE PRINT
	INC DI
	LOOP B

PRINT:
	MOV DX, DI
	MOV AH, 09H
	INT 21H

	POP AX
	CALL PRINT_ENTER
	MOV DL, AH
	CALL PRINT_2_HEX
	MOV DL, AL
	CALL PRINT_2_HEX

	MOV AH, 4CH
	INT 21H

CALCULATE_SQUARE:  ; AX = AL * AL = DS:[SI] * DS:[SI] = INPUT * INPUT
	MOV AL, [SI]
	MUL DL
RET

INPUT_1_HEX:
	PUSHF
	PUSH BX
	MOV BH, AH
	MOV AH, 01H
	INT 21H
	CMP AL, 'A'
	JB I1
	SUB AL, 37H
	JMP SHORT RETURN
I1:
	SUB AL, 30H
RETURN:
	MOV AH, BH
	POP BX
	POPF
RET

INPUT_2_HEX:
	PUSH AX
	PUSHF
	CALL INPUT_1_HEX
	MOV DL, AL
	MOV AL, 10H
	MUL DL
	MOV DL, AL
	CALL INPUT_1_HEX
	ADD DL, AL
	POPF
	POP AX
RET

PRINT_1_DEC:
	MOV DX, DI
	MOV AH, 9
	INT 21H
RET

PRINT_1_HEX:
	PUSH AX
	PUSH DX
	PUSHF
	CMP DL, 0AH
	JB P1
	ADD DL, 7H
P1:
	ADD DL, 30H
	MOV AH, 02H
	INT 21H
	POPF
	POP DX
	POP AX
RET

PRINT_2_HEX:
	PUSH AX
	PUSH DX
	PUSHF
	MOV AL, DL
	MOV AH, 0
	MOV DL, 10H
	DIV DL
	MOV DL, AL
	CALL PRINT_1_HEX
	MOV DL, AH
	CALL PRINT_1_HEX
	POPF
	POP DX
	POP AX
RET

PRINT_BLACK:
	PUSH AX
	PUSH DX
	MOV DL, ' '
	MOV AH, 02H
	INT 21H
	POP DX
	POP AX
RET

PRINT_ENTER:
	PUSH AX
	PUSH DX
	MOV  DL, 0DH
	MOV  AH, 02H
	INT  21H
	MOV  DL, 0AH
	MOV  AH, 02H
	INT  21H
	POP  DX
	POP  AX
RET
CODE ENDS

END START